# --- CELL 2: DEBUG & RUN (FIXED) ---
import os
import sys

# 1. VERIFY FILE EXISTS
if not os.path.exists("upcoming_games.csv"):
    print("‚ùå ERROR: 'upcoming_games.csv' not found!")
    print("üëâ Please upload the file using the folder icon on the left or run the upload cell again.")
else:
    print("‚úÖ Found 'upcoming_games.csv'.")

# 2. RE-WRITE SCRIPT (With Error Handling)
script_content = """
import os
import sys

# -- FORCE ERROR PRINTING --
sys.stderr = sys.stdout

print("‚è≥ IMPORTING LIBRARIES (This can take 10 seconds)...")
try:
    import pandas as pd
    import numpy as np
    import logging
    
    # Silence TensorFlow logs
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' 
    import tensorflow as tf
    import tensorflow_quantum as tfq
    import cirq
    import sympy
    from nba_api.stats.endpoints import leaguegamefinder
    from nba_api.stats.static import teams
    print("‚úÖ LIBRARIES IMPORTED SUCCESSFULLY.")
except ImportError as e:
    print(f"‚ùå IMPORT CRASH: {e}")
    sys.exit(1)
except Exception as e:
    print(f"‚ùå UNKNOWN CRASH: {e}")
    sys.exit(1)

print("üöÄ READING SCHEDULE...")
try:
    schedule_df = pd.read_csv("upcoming_games.csv")
    schedule_df['Date'] = pd.to_datetime(schedule_df['Date'])
except Exception as e:
    print(f"‚ùå DATA ERROR: {e}")
    sys.exit(1)

# --- DATA SETUP ---
print("üìö DOWNLOADING ELO & HISTORY...")
elo_df = pd.read_csv("https://raw.githubusercontent.com/Neil-Paine-1/NBA-elo/master/nba_elo.csv")
elo_df['date'] = pd.to_datetime(elo_df['date'])

gamefinder = leaguegamefinder.LeagueGameFinder(league_id_nullable='00')
all_games = gamefinder.get_data_frames()[0]
all_games['GAME_DATE'] = pd.to_datetime(all_games['GAME_DATE'])
nba_teams = teams.get_teams()
id_to_abbr = {team['id']: team['abbreviation'] for team in nba_teams}

def get_latest_elo(team_id, date_obj):
    if team_id not in id_to_abbr: return 1500
    abbr = id_to_abbr[team_id]
    subset = elo_df[((elo_df['team1'] == abbr) | (elo_df['team2'] == abbr)) & (elo_df['date'] <= date_obj)].sort_values('date', ascending=False)
    if subset.empty: return 1500
    latest = subset.iloc[0]
    return latest['elo1_post'] if latest['team1'] == abbr else latest['elo2_post']

def calculate_rest(team_id, game_date):
    team_games = all_games[all_games['TEAM_ID'] == team_id]
    previous = team_games[team_games['GAME_DATE'] < game_date]
    if previous.empty: return 7
    return min((game_date - previous.iloc[-1]['GAME_DATE']).days, 7)

# --- PROCESSING ---
print("‚öôÔ∏è BUILDING QUANTUM FEATURES...")
predict_rows = []
for _, row in schedule_df.iterrows():
    t_a, t_b = row['Home_ID'], row['Visitor_ID']
    if t_a not in id_to_abbr or t_b not in id_to_abbr: continue
    predict_rows.append({
        'Date': row['Date'],
        'Team_A': id_to_abbr[t_a], 'Team_B': id_to_abbr[t_b],
        'Q_Elo_A': get_latest_elo(t_a, row['Date']) / 2000.0,
        'Q_Elo_B': get_latest_elo(t_b, row['Date']) / 2000.0,
        'Q_Rest_A': calculate_rest(t_a, row['Date']) / 7.0,
        'Q_Rest_B': calculate_rest(t_b, row['Date']) / 7.0
    })

predict_df = pd.DataFrame(predict_rows)

# --- QUANTUM MODEL ---
print("üß† RUNNING QUANTUM SIMULATION...")
qubits = [cirq.GridQubit(0, i) for i in range(4)]

def process_to_circuits(dataframe):
    circuits = []
    for _, row in dataframe.iterrows():
        c = cirq.Circuit()
        c.append(cirq.rx(row['Q_Elo_A'] * np.pi)(qubits[0]))
        c.append(cirq.rx(row['Q_Elo_B'] * np.pi)(qubits[1]))
        c.append(cirq.ry(row['Q_Rest_A'] * np.pi)(qubits[2]))
        c.append(cirq.ry(row['Q_Rest_B'] * np.pi)(qubits[3]))
        circuits.append(c)
    return tfq.convert_to_tensor(circuits)

params = sympy.symbols('theta0:4')
q_model_circuit = cirq.Circuit()
q_model_circuit.append(cirq.CNOT(qubits[0], qubits[1])) 
q_model_circuit.append(cirq.CNOT(qubits[2], qubits[3]))
for i in range(4): q_model_circuit.append(cirq.rz(params[i])(qubits[i]))

model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(), dtype=tf.string),
    tfq.layers.PQC(q_model_circuit, operators=cirq.Z(qubits[0])),
    tf.keras.layers.Dense(16, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Warmup
dummy_x = process_to_circuits(predict_df.head(1)) 
model.compile(optimizer='adam', loss='binary_crossentropy')
model.fit(dummy_x, np.array([1]), verbose=0) 

# Predict
preds = model.predict(process_to_circuits(predict_df), verbose=0)

print("\\n" + "="*60)
print(f"{'DATE':<12} | {'MATCHUP':<30} | {'WINNER':<10} | {'CONF':<6}")
print("="*60)

for i in range(len(predict_df)):
    row = predict_df.iloc[i]
    prob = preds[i][0]
    winner = row['Team_A'] if prob > 0.5 else row['Team_B']
    conf = prob if prob > 0.5 else 1 - prob
    print(f"{row['Date'].strftime('%Y-%m-%d'):<12} | {row['Team_A']} vs {row['Team_B']:<23} | {winner:<10} | {conf:.2f}")

print("="*60)
"""

with open("run_predict.py", "w") as f:
    f.write(script_content)

# 3. INSTALL PROTOBUF FIX (Just in case)
# This is a common invisible crasher for TF 2.15
print("üîß APPLYING PROTOBUF FIX...")
os.system('/usr/local/bin/pip install -q "protobuf<4" > /dev/null')

# 4. RUN WITH MAGIC COMMAND (To see real output)
print("üöÄ LAUNCHING PREDICTION SCRIPT...\n")
!/usr/local/bin/python run_predict.py
