# --- CELL 2: EXECUTION SCRIPT (FIXED: REMOVED NESTED TRIPLE QUOTES) ---
# This script writes the main logic to a .py file and executes it in the 
# quantum_env environment setup in Cell 1.

import os
import sys
import pandas as pd
from datetime import datetime, timedelta
import numpy as np

# Define the environment executable path and script name
PYTHON_EXEC = '/usr/local/envs/quantum_env/bin/python'
script_name = "run_live_bets_final.py"

print("â³ WRITING PYTHON SCRIPT TO FILE...")

# --- THE SCRIPT CONTENT ---
# FIX: Replaced inner """ docstrings with # comments to prevent syntax errors.
script_content = """
import os
import sys
import tensorflow as tf
import tensorflow_quantum as tfq
import cirq
import sympy
import pandas as pd
import numpy as np
from nba_api.stats.endpoints import leaguegamefinder
from datetime import datetime, timedelta
import time

# Environment check
sys.path.append('/usr/local/envs/quantum_env/lib/python3.9/site-packages')
os.environ['PATH'] = os.environ['PATH'] + ':/usr/local/envs/quantum_env/bin'

# ==========================================
# PART 1: DATA SETUP (7-DAY LOOKAHEAD & FILTERING)
# ==========================================
print("\\nðŸ€ DOWNLOADING & TRAINING... Please wait for file output.")

# --- 1a. Fetch ELO data ---
elo_url = "https://raw.githubusercontent.com/Neil-Paine-1/NBA-elo/master/nba_elo.csv"
try:
    elo_df = pd.read_csv(elo_url)
    elo_df['date'] = pd.to_datetime(elo_df['date'])
except Exception:
    print("âŒ Failed to load ELO data.")
    sys.exit(1)

# --- 1b. Fetch NBA Game Data ---
gamefinder = leaguegamefinder.LeagueGameFinder(league_id_nullable='00')
time.sleep(1) # Respect API rate limits
all_games = gamefinder.get_data_frames()[0]
all_games['GAME_DATE'] = pd.to_datetime(all_games['GAME_DATE'])

# Filter data to the current season/relevant start date
start_date = pd.to_datetime('2023-10-01')
all_games = all_games[(all_games['GAME_DATE'] >= start_date)].sort_values('GAME_DATE')

# Define 7-day cutoff for predictions
future_cutoff_date = pd.Timestamp.now().normalize() + pd.Timedelta(days=7) 

# Filter games: Past games (for training) or scheduled within 7 days (for prediction)
all_games_filtered = all_games[
    (all_games['GAME_DATE'].dt.normalize() <= future_cutoff_date)
].copy()


def calculate_rest(team_id, game_date, all_games_df):
    # Calculates days of rest, capped at 7 days.
    team_games = all_games_df[all_games_df['TEAM_ID'] == team_id]
    previous = team_games[team_games['GAME_DATE'] < game_date]
    if previous.empty: return 7
    return min((game_date - previous.iloc[-1]['GAME_DATE']).days, 7)

train_rows = []
predict_rows = []
unique_game_ids = all_games_filtered['GAME_ID'].unique()

for gid in unique_game_ids:
    g_data = all_games_filtered[all_games_filtered['GAME_ID'] == gid]
    if len(g_data) < 2: continue

    team_a, team_b = g_data.iloc[0], g_data.iloc[1]
    
    # --- ELO Data Lookup and Mapping FIX ---
    row_elo_match = elo_df[
        (elo_df['date'] == team_a['GAME_DATE']) & 
        ((elo_df['team1'] == team_a['TEAM_ABBREVIATION']) | (elo_df['team2'] == team_a['TEAM_ABBREVIATION']))
    ]
    if row_elo_match.empty: continue
    row_elo = row_elo_match.iloc[0]

    # Check completion: A game is complete if the 'WL' column is not NaN (has a result)
    is_completed = pd.notna(team_a['WL'])
    
    # Map ELO scores correctly
    if row_elo['team1'] == team_a['TEAM_ABBREVIATION']:
        elo_a = row_elo['elo1_pre']
        elo_b = row_elo['elo2_pre']
    elif row_elo['team2'] == team_a['TEAM_ABBREVIATION']:
        elo_a = row_elo['elo2_pre']
        elo_b = row_elo['elo1_pre']
    else:
        continue

    # --- Feature Normalization ---
    features = {
        'Date': team_a['GAME_DATE'],
        'Team_A': team_a['TEAM_ABBREVIATION'],
        'Team_B': team_b['TEAM_ABBREVIATION'],
        'Q_Elo_A': elo_a / 2000.0,
        'Q_Elo_B': elo_b / 2000.0,
        'Q_Rest_A': calculate_rest(team_a['TEAM_ID'], team_a['GAME_DATE'], all_games_filtered) / 7.0,
        'Q_Rest_B': calculate_rest(team_b['TEAM_ID'], team_b['GAME_DATE'], all_games_filtered) / 7.0,
    }

    if is_completed:
        features['Winner'] = 1 if team_a['WL'] == 'W' else 0
        train_rows.append(features)
    else: 
        predict_rows.append(features)

train_df = pd.DataFrame(train_rows)
predict_df = pd.DataFrame(predict_rows)

# ==========================================
# PART 2: QUANTUM TRAINING
# ==========================================
qubits = [cirq.GridQubit(0, i) for i in range(4)]

def process_to_circuits(dataframe):
    # Converts a DataFrame of normalized features into a batch of Cirq circuits.
    if dataframe.empty:
        return tfq.convert_to_tensor([cirq.Circuit()])
        
    circuits = []
    for _, row in dataframe.iterrows():
        c = cirq.Circuit()
        c.append(cirq.rx(row['Q_Elo_A'] * np.pi)(qubits[0]))
        c.append(cirq.rx(row['Q_Elo_B'] * np.pi)(qubits[1]))
        c.append(cirq.ry(row['Q_Rest_A'] * np.pi)(qubits[2]))
        c.append(cirq.ry(row['Q_Rest_B'] * np.pi)(qubits[3]))
        circuits.append(c)
    return tfq.convert_to_tensor(circuits)

# Prepare training data
X_train = process_to_circuits(train_df)
y_train = np.array(train_df['Winner'])

# Define the Parametrized Quantum Circuit (PQC) structure
params = sympy.symbols('theta0:4')
q_model_circuit = cirq.Circuit()
q_model_circuit.append(cirq.CNOT(qubits[0], qubits[1])) 
q_model_circuit.append(cirq.CNOT(qubits[2], qubits[3]))
for i in range(4): q_model_circuit.append(cirq.rz(params[i])(qubits[i]))

# Build the Hybrid Quantum-Classical Model
model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(), dtype=tf.string),
    tfq.layers.PQC(q_model_circuit, operators=cirq.Z(qubits[0])),
    tf.keras.layers.Dense(16, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Compile and Train the model
model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.01), loss='binary_crossentropy', metrics=['accuracy'])

if len(train_df) > 10:
    model.fit(X_train, y_train, epochs=15, batch_size=32, verbose=0)
    print("âœ… Training complete.")
else:
    print("âš ï¸ WARNING: Insufficient training data. Model training skipped.")


# ==========================================
# PART 3: PREDICTION AND OUTPUT
# ==========================================
if predict_df.empty:
    print("âŒ No upcoming games found in the next 7 days to predict.")
else:
    X_predict = process_to_circuits(predict_df)
    predictions = model.predict(X_predict, verbose=0)
    
    results = []
    for i in range(len(predict_df)):
        row = predict_df.iloc[i]
        prob_a = predictions[i][0]
        
        # Determine the winner and confidence score
        if prob_a > 0.5:
            predicted_winner = row['Team_A']
            confidence = prob_a
        else:
            predicted_winner = row['Team_B']
            confidence = 1 - prob_a

        # Betting Advice Logic
        advice = ""
        if confidence >= 0.65: advice = "STRONG BET"
        elif confidence >= 0.60: advice = "MODERATE BET"
        else: advice = "AVOID"

        results.append({
            'Date': row['Date'].strftime('%Y-%m-%d'),
            'Matchup': f"{row['Team_A']} vs {row['Team_B']}",
            'Predicted_Winner': predicted_winner,
            'Confidence_Score': f"{confidence:.3f}",
            'Betting_Advice': advice
        })
    
    output_df = pd.DataFrame(results)
    output_df.to_csv('quantum_nba_predictions.csv', index=False)
    
    print("âœ… PREDICTIONS SAVED!")
    print(" Â  Find 'quantum_nba_predictions.csv' in the Colab files list.")
    print(f" Â  {len(output_df)} predictions generated for upcoming games.")
"""

# ---------------------------------
# EXECUTION
# ---------------------------------
# Write the script content to the file
with open(script_name, "w") as f:
    f.write(script_content)

print("ðŸš€ LAUNCHING SCRIPT...")
# Execute the written Python script using the configured environment Python
os.system(f'{PYTHON_EXEC} {script_name}')
